# ‚òÅÔ∏è Caso Pr√°ctico: Debugging de Aplicaciones en GKE

## üìë √çndice

* [üß≠ Escenario del Problema](#-escenario-del-problema)
* [üõ†Ô∏è Kit de Herramientas de Debugging en GKE](#Ô∏è-kit-de-herramientas-de-debugging-en-gke)
* [üïµÔ∏è‚Äç‚ôÇÔ∏è Proceso de Debugging por Capas](#Ô∏è-proceso-de-debugging-por-capas)
* [üî¨ Laboratorio Pr√°ctico (Simulaci√≥n de Errores)](#-laboratorio-pr√°ctico-simulaci√≥n-de-errores)
* [üí° Lecciones Aprendidas](#-lecciones-aprendidas)
* [üßæ Resumen](#-resumen)
* [‚úçÔ∏è Firma](#-firma)

---

## üß≠ Escenario del Problema

Un desarrollador despliega una nueva versi√≥n de su aplicaci√≥n en un cl√∫ster de GKE. Despu√©s de aplicar el manifiesto `deployment.yaml`, el desarrollador ejecuta `kubectl get pods` y observa que los Pods de su aplicaci√≥n no alcanzan el estado `Running`. En su lugar, se quedan atascados en estados como `ImagePullBackOff`, `CrashLoopBackOff` o `Pending`.

**Objetivo:** Proporcionar una gu√≠a sistem√°tica y "pasito a pasito" para diagnosticar y resolver los problemas m√°s comunes que impiden que un Pod se ejecute correctamente en GKE.

---

## üõ†Ô∏è Kit de Herramientas de Debugging en GKE

La herramienta principal es `kubectl`, el cuchillo suizo para interactuar con Kubernetes.

1.  **`kubectl get pods -o wide`**: Para obtener una lista de los Pods, su estado, en qu√© nodo se est√°n ejecutando y sus IPs.
2.  **`kubectl describe pod <pod-name>`**: **La herramienta m√°s importante.** Proporciona una descripci√≥n detallada del estado del Pod, su configuraci√≥n y, lo m√°s crucial, una secci√≥n de **Eventos** al final que narra por qu√© no se est√° ejecutando.
3.  **`kubectl logs <pod-name>`**: Para ver la salida est√°ndar (stdout) de la aplicaci√≥n dentro del contenedor. Si el Pod lleg√≥ a iniciarse y luego fall√≥, aqu√≠ estar√°n los logs de la aplicaci√≥n.
4.  **`kubectl logs <pod-name> --previous`**: Para ver los logs de la √∫ltima vez que el contenedor fall√≥ (en caso de un `CrashLoopBackOff`).
5.  **`kubectl exec -it <pod-name> -- /bin/sh`**: Para obtener una shell interactiva dentro de un contenedor que s√≠ est√° corriendo. Permite probar la conectividad de red, verificar archivos, etc.

---

## üïµÔ∏è‚Äç‚ôÇÔ∏è Proceso de Debugging por Capas

Se debe abordar el debugging seg√∫n el estado en el que se encuentra el Pod.

### Escenario 1: El Pod est√° en estado `Pending`

**Significado:** El Pod ha sido aceptado por Kubernetes, pero no puede ser asignado a un nodo para ejecutarse.

1.  **Diagn√≥stico:** Ejecuta `kubectl describe pod <pod-name>`. Mira la secci√≥n de **Eventos**.
2.  **Causas Comunes y Soluciones:**
    *   **Recursos Insuficientes:** El evento dir√° algo como `0/3 nodes are available: 3 Insufficient cpu/memory`. El cl√∫ster no tiene suficientes recursos para satisfacer las `requests` de CPU o memoria del Pod.
        *   **Soluci√≥n:** A√±adir m√°s nodos al cl√∫ster, usar nodos m√°s grandes, o reducir las `requests` de recursos del Pod si son demasiado altas.
    *   **Taints y Tolerations:** El evento puede indicar que los nodos tienen `taints` (marcas) que el Pod no `tolera`. Por ejemplo, un nodo puede estar reservado solo para cargas de trabajo espec√≠ficas.
        *   **Soluci√≥n:** A√±adir la `toleration` correspondiente al manifiesto del Pod o eliminar el `taint` del nodo si es incorrecto.
    *   **Afinidad de Nodos/Pods:** Las reglas de `nodeAffinity` o `podAntiAffinity` pueden estar impidiendo que el Pod se programe.
        *   **Soluci√≥n:** Revisar y ajustar estas reglas en el manifiesto del Deployment.

### Escenario 2: El Pod est√° en estado `ImagePullBackOff` o `ErrImagePull`

**Significado:** El Kubelet en el nodo no puede descargar la imagen de contenedor especificada.

1.  **Diagn√≥stico:** `kubectl describe pod <pod-name>`. El evento mostrar√° un error como `Failed to pull image ... repository not found or may require 'docker login'`.
2.  **Causas Comunes y Soluciones:**
    *   **Nombre de Imagen Incorrecto:** Un simple error tipogr√°fico en el nombre de la imagen en el manifiesto del Deployment.
        *   **Soluci√≥n:** Corregir el nombre de la imagen y volver a aplicar el manifiesto.
    *   **Permisos de Acceso al Registro:** El cl√∫ster de GKE no tiene permisos para acceder al registro de contenedores (ej. Artifact Registry). Esto es com√∫n si el registro est√° en un proyecto diferente.
        *   **Soluci√≥n:** Asegurarse de que los nodos del cl√∫ster (su cuenta de servicio) tengan el rol `roles/storage.objectViewer` para GCR o `roles/artifactregistry.reader` para Artifact Registry.
    *   **La Imagen no Existe:** El tag de la imagen especificado no existe en el repositorio.
        *   **Soluci√≥n:** Verificar en Artifact Registry que la imagen y el tag existen.

### Escenario 3: El Pod est√° en estado `CrashLoopBackOff`

**Significado:** El contenedor se inicia, pero falla (crashea) inmediatamente. Kubernetes intenta reiniciarlo una y otra vez, y entra en un bucle de fallos.

1.  **Diagn√≥stico:** Este es un problema de la **aplicaci√≥n**, no de Kubernetes.
    *   Primero, usa `kubectl logs <pod-name>` para ver el error que la aplicaci√≥n est√° arrojando. Puede ser un error de conexi√≥n a la base de datos, una variable de entorno que falta, etc.
    *   Si los logs se mueven demasiado r√°pido, usa `kubectl logs <pod-name> --previous` para ver los logs de la terminaci√≥n anterior.
2.  **Causas Comunes y Soluciones:**
    *   **Error en el C√≥digo de la Aplicaci√≥n:** Un bug que causa una excepci√≥n no controlada al inicio.
        *   **Soluci√≥n:** Arreglar el c√≥digo de la aplicaci√≥n.
    *   **Configuraci√≥n Incorrecta:** La aplicaci√≥n no puede encontrar un archivo de configuraci√≥n, una variable de entorno o un secreto que necesita para arrancar.
        *   **Soluci√≥n:** Verificar que los `ConfigMaps` y `Secrets` est√°n montados correctamente y que las variables de entorno est√°n bien definidas en el manifiesto.
    *   **Problemas de Conectividad:** La aplicaci√≥n no puede conectarse a una base de datos u otro servicio en el arranque.
        *   **Soluci√≥n:** Usar `kubectl exec` en un Pod que funcione para probar la conectividad (`ping`, `curl`) al servicio dependiente. Revisar las `NetworkPolicies`.
    *   **Health Checks Mal Configurados:** La `livenessProbe` (sonda de vida) est√° fallando porque la aplicaci√≥n tarda demasiado en arrancar o el endpoint de la sonda es incorrecto. Kubernetes mata el Pod porque piensa que no est√° sano.
        *   **Soluci√≥n:** Aumentar el `initialDelaySeconds` de la sonda o corregir el `path` o `port`.

---

## üî¨ Laboratorio Pr√°ctico (Simulaci√≥n de Errores)

### 1. Simular `ImagePullBackOff`

```bash
# ARRANGE: Crear un manifiesto con un nombre de imagen incorrecto
cat > deployment-error1.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata: {name: nginx-error1}
spec:
  replicas: 1
  selector: {matchLabels: {app: nginx-error1}}
  template:
    metadata: {labels: {app: nginx-error1}}
    spec:
      containers:
      - name: nginx
        image: nginx:1.999 # Tag que no existe
        ports: [{containerPort: 80}]
EOF

# ACT: Aplicar el manifiesto
kubectl apply -f deployment-error1.yaml

# ASSERT: Diagnosticar el problema
sleep 10 # Dar tiempo a que falle
export POD_NAME=$(kubectl get pods -l app=nginx-error1 -o jsonpath="{.items[0].metadata.name}")
kubectl get pod $POD_NAME # Ver√°s ImagePullBackOff
kubectl describe pod $POD_NAME # Ver√°s el evento de "Failed to pull image"

# CLEANUP
kubectl delete -f deployment-error1.yaml
```

### 2. Simular `CrashLoopBackOff`

```bash
# ARRANGE: Crear un manifiesto que ejecuta un comando que falla
cat > deployment-error2.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata: {name: alpine-error2}
spec:
  replicas: 1
  selector: {matchLabels: {app: alpine-error2}}
  template:
    metadata: {labels: {app: alpine-error2}}
    spec:
      containers:
      - name: alpine
        image: alpine
        command: ["/bin/sh", "-c", "echo 'Voy a fallar...'; exit 1"]
EOF

# ACT: Aplicar el manifiesto
kubectl apply -f deployment-error2.yaml

# ASSERT: Diagnosticar el problema
sleep 10
export POD_NAME=$(kubectl get pods -l app=alpine-error2 -o jsonpath="{.items[0].metadata.name}")
kubectl get pod $POD_NAME # Ver√°s CrashLoopBackOff
kubectl logs $POD_NAME # Ver√°s el mensaje "Voy a fallar..."

# CLEANUP
kubectl delete -f deployment-error2.yaml
```

---

## üí° Lecciones Aprendidas

*   **`kubectl describe` es tu Mejor Amigo:** El 90% de los problemas de infraestructura de Pods (scheduling, pull de im√°genes) se resuelven leyendo la secci√≥n de **Eventos** de `kubectl describe pod`.
*   **Distingue Problemas de Plataforma vs. Problemas de Aplicaci√≥n:** `Pending` e `ImagePullBackOff` son problemas de la **plataforma** (Kubernetes no puede ejecutar el Pod). `CrashLoopBackOff` es casi siempre un problema de la **aplicaci√≥n** (el c√≥digo dentro del contenedor est√° fallando).
*   **Piensa en Capas:** El debugging en Kubernetes es un proceso de eliminaci√≥n. ¬øPuede el Pod ser programado? Si s√≠, ¬øpuede la imagen ser descargada? Si s√≠, ¬øpuede la aplicaci√≥n arrancar y mantenerse saludable? Aborda cada capa por separado.

---

## üßæ Resumen

El debugging en GKE es un proceso sistem√°tico que se basa en el uso de `kubectl` para inspeccionar el estado y los eventos de los recursos. Al entender los diferentes estados de un Pod (`Pending`, `ImagePullBackOff`, `CrashLoopBackOff`), un desarrollador puede r√°pidamente acotar la causa del problema, ya sea un problema de recursos del cl√∫ster, de configuraci√≥n del manifiesto o un bug en el propio c√≥digo de la aplicaci√≥n. La clave es seguir la pista que dejan los **eventos** y los **logs**.

---

## ‚úçÔ∏è Firma

**Marco - DevSecOps Kulture**  
*The Artisan Path*  
üìß Contacto: [markitos.es.info@gmail.com](mailto:markitos.es.info@gmail.com)  
üêô GitHub: [https://github.com/markitos-public](https://github.com/markitos-public)

---

[‚¨ÜÔ∏è **Volver arriba**](#-caso-pr√°ctico-debugging-de-aplicaciones-en-gke)
